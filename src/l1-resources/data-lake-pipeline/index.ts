// Generated by cdk-import
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";

/**
 * Data Lake is deprecated. As of September 2024, Data Lake is deprecated. If you use Data Lake, you should migrate to alternative solutions before the service is removed. To learn more, see <https://dochub.mongodb.org/core/data-lake-deprecation>. This resource returns, adds, edits, and removes data lake pipelines.
 *
 * @schema CfnDataLakePipelineProps
 */
export interface CfnDataLakePipelineProps {
  /**
   * Profile used to provide credentials information, (a secret with the cfn/atlas/profile/{Profile}, is required), if not provided default is used
   *
   * @schema CfnDataLakePipelineProps#Profile
   */
  readonly profile?: string;

  /**
   * Unique 24-hexadecimal digit string that identifies your project.
   *
   * @schema CfnDataLakePipelineProps#ProjectId
   */
  readonly projectId: string;

  /**
   * State of the Data Lake Pipeline.
   *
   * @schema CfnDataLakePipelineProps#State
   */
  readonly state?: string;

  /**
   * Name of this Data Lake Pipeline.
   *
   * @schema CfnDataLakePipelineProps#Name
   */
  readonly name: string;

  /**
   * @schema CfnDataLakePipelineProps#Sink
   */
  readonly sink: Sink;

  /**
   * @schema CfnDataLakePipelineProps#Source
   */
  readonly source?: Source;

  /**
   * Ingestion destination of a Data Lake Pipeline.
   *
   * @schema CfnDataLakePipelineProps#Transformations
   */
  readonly transformations: Transformations[];
}

/**
 * Converts an object of type 'CfnDataLakePipelineProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CfnDataLakePipelineProps(
  obj: CfnDataLakePipelineProps | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    Profile: obj.profile,
    ProjectId: obj.projectId,
    State: obj.state,
    Name: obj.name,
    Sink: toJson_Sink(obj.sink),
    Source: toJson_Source(obj.source),
    Transformations: obj.transformations?.map((y) => toJson_Transformations(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {}
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Ingestion destination of a Data Lake Pipeline.
 *
 * @schema sink
 */
export interface Sink {
  /**
   * Type of ingestion destination of this Data Lake Pipeline.
   *
   * @schema sink#Type
   */
  readonly type?: SinkType;

  /**
   * Target cloud provider for this Data Lake Pipeline.
   *
   * @schema sink#MetadataProvider
   */
  readonly metadataProvider?: string;

  /**
   * Target cloud provider region for this Data Lake Pipeline.
   *
   * @schema sink#MetadataRegion
   */
  readonly metadataRegion?: string;

  /**
   * Ordered fields used to physically organize data in the destination.
   *
   * @schema sink#PartitionFields
   */
  readonly partitionFields?: PartitionFields[];
}

/**
 * Converts an object of type 'Sink' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Sink(
  obj: Sink | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    Type: obj.type,
    MetadataProvider: obj.metadataProvider,
    MetadataRegion: obj.metadataRegion,
    PartitionFields: obj.partitionFields?.map((y) => toJson_PartitionFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {}
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Ingestion destination of a Data Lake Pipeline.
 *
 * @schema source
 */
export interface Source {
  /**
   * Type of ingestion source of this Data Lake Pipeline.
   *
   * @schema source#Type
   */
  readonly type?: SourceType;

  /**
   * Human-readable name that identifies the cluster.
   *
   * @schema source#ClusterName
   */
  readonly clusterName?: string;

  /**
   * Human-readable name that identifies the collection.
   *
   * @schema source#CollectionName
   */
  readonly collectionName?: string;

  /**
   * Human-readable name that identifies the database.
   *
   * @schema source#DatabaseName
   */
  readonly databaseName?: string;

  /**
   * Unique 24-hexadecimal character string that identifies the project.
   *
   * @schema source#GroupId
   */
  readonly groupId?: string;
}

/**
 * Converts an object of type 'Source' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Source(
  obj: Source | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    Type: obj.type,
    ClusterName: obj.clusterName,
    CollectionName: obj.collectionName,
    DatabaseName: obj.databaseName,
    GroupId: obj.groupId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {}
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Ordered fields used to physically organize data in the destination.
 *
 * @schema transformations
 */
export interface Transformations {
  /**
   * Key in the document.
   *
   * @schema transformations#Field
   */
  readonly field?: string;

  /**
   * Type of transformation applied during the export of the namespace in a Data Lake Pipeline.
   *
   * @schema transformations#Type
   */
  readonly type?: string;
}

/**
 * Converts an object of type 'Transformations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Transformations(
  obj: Transformations | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    Field: obj.field,
    Type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {}
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Type of ingestion destination of this Data Lake Pipeline.
 *
 * @schema SinkType
 */
export enum SinkType {
  /** DLS */
  DLS = "DLS",
}

/**
 * Ordered fields used to physically organize data in the destination.
 *
 * @schema partitionFields
 */
export interface PartitionFields {
  /**
   * Human-readable label that identifies the field name used to partition data.
   *
   * @schema partitionFields#FieldName
   */
  readonly fieldName?: string;

  /**
   * Sequence in which MongoDB Cloud slices the collection data to create partitions. The resource expresses this sequence starting with zero.
   *
   * @schema partitionFields#Order
   */
  readonly order?: number;
}

/**
 * Converts an object of type 'PartitionFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PartitionFields(
  obj: PartitionFields | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    FieldName: obj.fieldName,
    Order: obj.order,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {}
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Type of ingestion source of this Data Lake Pipeline.
 *
 * @schema SourceType
 */
export enum SourceType {
  /** ON_DEMAND_CPS */
  ON_DEMAND_CPS = "ON_DEMAND_CPS",
  /** PERIODIC_CPS */
  PERIODIC_CPS = "PERIODIC_CPS",
}

/**
 * A CloudFormation `MongoDB::Atlas::DataLakePipeline`
 *
 * @cloudformationResource MongoDB::Atlas::DataLakePipeline
 * @stability external
 */
export class CfnDataLakePipeline extends cdk.CfnResource {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME =
    "MongoDB::Atlas::DataLakePipeline";

  /**
   * Resource props.
   */
  public readonly props: CfnDataLakePipelineProps;

  /**
   * Attribute `MongoDB::Atlas::DataLakePipeline.CreatedDate`
   */
  public readonly attrCreatedDate: string;
  /**
   * Attribute `MongoDB::Atlas::DataLakePipeline.Id`
   */
  public readonly attrId: string;
  /**
   * Attribute `MongoDB::Atlas::DataLakePipeline.LastUpdatedDate`
   */
  public readonly attrLastUpdatedDate: string;

  /**
   * Create a new `MongoDB::Atlas::DataLakePipeline`.
   *
   * @param scope - scope in which this resource is defined
   * @param id    - scoped id of the resource
   * @param props - resource properties
   */
  constructor(
    scope: constructs.Construct,
    id: string,
    props: CfnDataLakePipelineProps
  ) {
    super(scope, id, {
      type: CfnDataLakePipeline.CFN_RESOURCE_TYPE_NAME,
      properties: toJson_CfnDataLakePipelineProps(props)!,
    });

    this.props = props;

    this.attrCreatedDate = cdk.Token.asString(this.getAtt("CreatedDate"));
    this.attrId = cdk.Token.asString(this.getAtt("Id"));
    this.attrLastUpdatedDate = cdk.Token.asString(
      this.getAtt("LastUpdatedDate")
    );
  }
}
