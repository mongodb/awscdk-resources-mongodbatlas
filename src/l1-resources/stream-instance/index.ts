// Generated by cdk-import
import * as cdk from "aws-cdk-lib";
import * as constructs from "constructs";

/**
 * Returns, adds, edits, and removes Atlas Stream Processing Instances. Note that Atlas Streams functionality is currently in [Public Preview](https://www.mongodb.com/blog/post/atlas-stream-processing-now-in-public-preview)
 *
 * @schema CfnStreamInstanceProps
 */
export interface CfnStreamInstanceProps {
  /**
   * The profile is defined in AWS Secret manager. See [Secret Manager Profile setup](../../../examples/profile-secret.yaml).
   *
   * @schema CfnStreamInstanceProps#Profile
   */
  readonly profile?: string;

  /**
   * Human-readable label that identifies the stream connection.
   *
   * @schema CfnStreamInstanceProps#InstanceName
   */
  readonly instanceName: string;

  /**
   * @schema CfnStreamInstanceProps#DataProcessRegion
   */
  readonly dataProcessRegion: StreamsDataProcessRegion;

  /**
   * @schema CfnStreamInstanceProps#StreamConfig
   */
  readonly streamConfig: StreamConfig;

  /**
   * @schema CfnStreamInstanceProps#Connections
   */
  readonly connections?: StreamsConnection[];

  /**
   * Unique 24-hexadecimal character string that identifies the project.
   *
   * @schema CfnStreamInstanceProps#ProjectId
   */
  readonly projectId: string;
}

/**
 * Converts an object of type 'CfnStreamInstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CfnStreamInstanceProps(
  obj: CfnStreamInstanceProps | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    Profile: obj.profile,
    InstanceName: obj.instanceName,
    DataProcessRegion: toJson_StreamsDataProcessRegion(obj.dataProcessRegion),
    StreamConfig: toJson_StreamConfig(obj.streamConfig),
    Connections: obj.connections?.map((y) => toJson_StreamsConnection(y)),
    ProjectId: obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {}
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Information about the cloud provider region in which MongoDB Cloud processes the stream.
 *
 * @schema StreamsDataProcessRegion
 */
export interface StreamsDataProcessRegion {
  /**
   * Label that identifies the cloud service provider where MongoDB Cloud performs stream processing. Currently, this parameter supports AWS only.
   *
   * @schema StreamsDataProcessRegion#CloudProvider
   */
  readonly cloudProvider: StreamsDataProcessRegionCloudProvider;

  /**
   * @schema StreamsDataProcessRegion#Region
   */
  readonly region: string;
}

/**
 * Converts an object of type 'StreamsDataProcessRegion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamsDataProcessRegion(
  obj: StreamsDataProcessRegion | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    CloudProvider: obj.cloudProvider,
    Region: obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {}
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration options for an Atlas Stream Processing Instance.
 *
 * @schema StreamConfig
 */
export interface StreamConfig {
  /**
   * Selected tier for the Stream Instance. Configures Memory / VCPU allowances.
   *
   * @schema StreamConfig#Tier
   */
  readonly tier?: string;
}

/**
 * Converts an object of type 'StreamConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamConfig(
  obj: StreamConfig | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    Tier: obj.tier,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {}
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Settings that define a connection to an external data store.
 *
 * @schema StreamsConnection
 */
export interface StreamsConnection {
  /**
   * Human-readable label that identifies the stream connection.
   *
   * @schema StreamsConnection#Name
   */
  readonly name?: string;

  /**
   * Type of the connection. Can be either Cluster or Kafka.
   *
   * @schema StreamsConnection#Type
   */
  readonly type?: StreamsConnectionType;

  /**
   * @schema StreamsConnection#Authentication
   */
  readonly authentication?: StreamsKafkaAuthentication;

  /**
   * Comma separated list of server addresses.
   *
   * @schema StreamsConnection#BootstrapServers
   */
  readonly bootstrapServers?: string;

  /**
   * @schema StreamsConnection#Security
   */
  readonly security?: StreamsKafkaSecurity;

  /**
   * Name of the cluster configured for this connection.
   *
   * @schema StreamsConnection#ClusterName
   */
  readonly clusterName?: string;

  /**
   * @schema StreamsConnection#DbRoleToExecute
   */
  readonly dbRoleToExecute?: DbRoleToExecute;
}

/**
 * Converts an object of type 'StreamsConnection' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamsConnection(
  obj: StreamsConnection | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    Name: obj.name,
    Type: obj.type,
    Authentication: toJson_StreamsKafkaAuthentication(obj.authentication),
    BootstrapServers: obj.bootstrapServers,
    Security: toJson_StreamsKafkaSecurity(obj.security),
    ClusterName: obj.clusterName,
    DbRoleToExecute: toJson_DbRoleToExecute(obj.dbRoleToExecute),
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {}
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Label that identifies the cloud service provider where MongoDB Cloud performs stream processing. Currently, this parameter supports AWS only.
 *
 * @schema StreamsDataProcessRegionCloudProvider
 */
export enum StreamsDataProcessRegionCloudProvider {
  /** AWS */
  AWS = "AWS",
  /** GCP */
  GCP = "GCP",
  /** AZURE */
  AZURE = "AZURE",
  /** TENANT */
  TENANT = "TENANT",
  /** SERVERLESS */
  SERVERLESS = "SERVERLESS",
}

/**
 * Type of the connection. Can be either Cluster or Kafka.
 *
 * @schema StreamsConnectionType
 */
export enum StreamsConnectionType {
  /** Kafka */
  KAFKA = "Kafka",
  /** Cluster */
  CLUSTER = "Cluster",
  /** Sample */
  SAMPLE = "Sample",
}

/**
 * User credentials required to connect to a Kafka Cluster. Includes the authentication type, as well as the parameters for that authentication mode.
 *
 * @schema StreamsKafkaAuthentication
 */
export interface StreamsKafkaAuthentication {
  /**
   * Style of authentication. Can be one of PLAIN, SCRAM-256, or SCRAM-512.
   *
   * @schema StreamsKafkaAuthentication#Mechanism
   */
  readonly mechanism?: string;

  /**
   * Username of the account to connect to the Kafka cluster.
   *
   * @schema StreamsKafkaAuthentication#Username
   */
  readonly username?: string;
}

/**
 * Converts an object of type 'StreamsKafkaAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamsKafkaAuthentication(
  obj: StreamsKafkaAuthentication | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    Mechanism: obj.mechanism,
    Username: obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {}
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Properties for the secure transport connection to Kafka. For SSL, this can include the trusted certificate to use.
 *
 * @schema StreamsKafkaSecurity
 */
export interface StreamsKafkaSecurity {
  /**
   * A trusted, public x509 certificate for connecting to Kafka over SSL.
   *
   * @schema StreamsKafkaSecurity#BrokerPublicCertificate
   */
  readonly brokerPublicCertificate?: string;

  /**
   * Describes the transport type. Can be either PLAINTEXT or SSL.
   *
   * @schema StreamsKafkaSecurity#Protocol
   */
  readonly protocol?: string;
}

/**
 * Converts an object of type 'StreamsKafkaSecurity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StreamsKafkaSecurity(
  obj: StreamsKafkaSecurity | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    BrokerPublicCertificate: obj.brokerPublicCertificate,
    Protocol: obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {}
  );
}
/* eslint-enable max-len, quote-props */

/**
 * The name of a Built in or Custom DB Role to connect to an Atlas Cluster.
 *
 * @schema DBRoleToExecute
 */
export interface DbRoleToExecute {
  /**
   * The name of the role to use. Can be a built in role or a custom role.
   *
   * @schema DBRoleToExecute#Role
   */
  readonly role?: string;

  /**
   * Type of the DB role. Can be either BuiltIn or Custom.
   *
   * @schema DBRoleToExecute#Type
   */
  readonly type?: DbRoleToExecuteType;
}

/**
 * Converts an object of type 'DbRoleToExecute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DbRoleToExecute(
  obj: DbRoleToExecute | undefined
): Record<string, any> | undefined {
  if (obj === undefined) {
    return undefined;
  }
  const result = {
    Role: obj.role,
    Type: obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce(
    (r, i) => (i[1] === undefined ? r : { ...r, [i[0]]: i[1] }),
    {}
  );
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the DB role. Can be either BuiltIn or Custom.
 *
 * @schema DbRoleToExecuteType
 */
export enum DbRoleToExecuteType {
  /** BUILT_IN */
  BUILT_UNDERSCORE_IN = "BUILT_IN",
  /** CUSTOM */
  CUSTOM = "CUSTOM",
}

/**
 * A CloudFormation `MongoDB::Atlas::StreamInstance`
 *
 * @cloudformationResource MongoDB::Atlas::StreamInstance
 * @stability external
 */
export class CfnStreamInstance extends cdk.CfnResource {
  /**
   * The CloudFormation resource type name for this resource class.
   */
  public static readonly CFN_RESOURCE_TYPE_NAME =
    "MongoDB::Atlas::StreamInstance";

  /**
   * Resource props.
   */
  public readonly props: CfnStreamInstanceProps;

  /**
   * Attribute `MongoDB::Atlas::StreamInstance.Id`
   */
  public readonly attrId: string;
  /**
   * Attribute `MongoDB::Atlas::StreamInstance.Hostnames`
   */
  public readonly attrHostnames: string[];

  /**
   * Create a new `MongoDB::Atlas::StreamInstance`.
   *
   * @param scope - scope in which this resource is defined
   * @param id    - scoped id of the resource
   * @param props - resource properties
   */
  constructor(
    scope: constructs.Construct,
    id: string,
    props: CfnStreamInstanceProps
  ) {
    super(scope, id, {
      type: CfnStreamInstance.CFN_RESOURCE_TYPE_NAME,
      properties: toJson_CfnStreamInstanceProps(props)!,
    });

    this.props = props;

    this.attrId = cdk.Token.asString(this.getAtt("Id"));
    this.attrHostnames = cdk.Token.asList(this.getAtt("Hostnames"));
  }
}
